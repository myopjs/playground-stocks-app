import { jsx as E, jsxs as ft } from "react/jsx-runtime";
import { useRef as H, useEffect as ee, useState as j, useCallback as ye } from "react";
var Re = Object.defineProperty, yt = Object.defineProperties, gt = Object.getOwnPropertyDescriptors, ge = Object.getOwnPropertySymbols, vt = Object.prototype.hasOwnProperty, wt = Object.prototype.propertyIsEnumerable, te = (e, t, s) => t in e ? Re(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, w = (e, t) => {
  for (var s in t || (t = {}))
    vt.call(t, s) && te(e, s, t[s]);
  if (ge)
    for (var s of ge(t))
      wt.call(t, s) && te(e, s, t[s]);
  return e;
}, W = (e, t) => yt(e, gt(t)), Mt = (e, t) => {
  for (var s in t)
    Re(e, s, { get: t[s], enumerable: !0 });
}, o = (e, t, s) => te(e, typeof t != "symbol" ? t + "" : t, s), y = (e, t, s) => new Promise((n, i) => {
  var r = (c) => {
    try {
      l(s.next(c));
    } catch (d) {
      i(d);
    }
  }, a = (c) => {
    try {
      l(s.throw(c));
    } catch (d) {
      i(d);
    }
  }, l = (c) => c.done ? n(c.value) : Promise.resolve(c.value).then(r, a);
  l((s = s.apply(e, t)).next());
}), G = "__federation__", ve = "onLoad", He = (e, t) => {
  window[G] && window[G][e] && window[G][e][ve] && window[G][e][ve]({ [e]: t });
}, g = {
  //host to component
  InitRequest: "InitRequest",
  InitResponse: "InitResponse",
  InitMessage: "InitMessage",
  DisposeMessage: "DisposeMessage",
  ChangeTextMessage: "ChangeTextMessage",
  BindClickMessage: "BindClickMessage",
  DetectMyopRefsMessage: "DetectMyopRefsMessage",
  ExecuteScriptMessage: "ExecuteScriptMessage",
  AddEventListenerMessage: "AddEventListenerMessage",
  SetAttributeMessage: "SetAttributeMessage",
  CreateRefComponentMessage: "CreateRefComponentMessage",
  EnvelopedMessage: "EnvelopedMessage",
  GetElementValueMessage: "GetElementValueMessage",
  SetInnerHtml: "SetInnerHtml",
  //component messages
  ExecuteComponentMethod: "ExecuteComponentMethod",
  CleanupMessage: "CleanupMessage",
  // external to host :
  In: {
    MutationObserverMessage: "MutationObserverMessage",
    ResizeObserverMessage: "ResizeObserverMessage"
  }
}, se = {};
Mt(se, {
  AddEventListenerMessage: () => Rt,
  BaseMyopMessage: () => M,
  BindClickMessage: () => St,
  ChangeTextMessage: () => It,
  CleanupMessage: () => Je,
  CleanupReplayMessage: () => Ze,
  ClickReplayMessage: () => $e,
  CreateRefComponentMessage: () => Ve,
  CustomRefMessage: () => ne,
  DetectMyopRefsMessage: () => $t,
  DetectedMyopRefsMessage: () => je,
  DisposeMessage: () => Xe,
  ElementValueReplayMessage: () => Ke,
  EnvelopedMessage: () => ze,
  EventListenerCallbackMessage: () => Pe,
  ExecuteComponentMethod: () => R,
  ExecuteScriptMessage: () => k,
  ExecuteScriptReplyMessage: () => Fe,
  GetAttributeMessage: () => Lt,
  GetAttributeReplayMessage: () => Ot,
  GetElementValueMessage: () => kt,
  InitMessage: () => le,
  InitRequest: () => Ne,
  InitResponse: () => Ue,
  MessageDirection: () => _,
  MutationObserverMessage: () => Bt,
  MyopBindMessage: () => S,
  MyopBindReplayMessage: () => b,
  MyopElementMessage: () => bt,
  Ref: () => N,
  RefComponentCreatedMessage: () => ie,
  ResizeObserverMessage: () => At,
  SetAttributeMessage: () => Ht,
  SetInnerHtml: () => Dt,
  SetMutationObserverMessage: () => Ft,
  SetResizeObserverMessage: () => Pt,
  stripFunction: () => Oe
});
var B = () => "10000000-1000-4000-8000-100000000000".replace(
  /[018]/g,
  (e) => (+e ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +e / 4).toString(16)
), Ct = (e) => {
  const t = [...e].map((s) => s.toString(16).padStart(2, "0")).join("");
  return [
    t.slice(0, 8),
    t.slice(8, 12),
    t.slice(12, 16),
    t.slice(16, 20),
    t.slice(20)
  ].join("-");
}, Et = (e) => {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  for (; t.length % 4; ) t += "=";
  const s = atob(t);
  return Uint8Array.from(s, (n) => n.charCodeAt(0));
}, we = (e) => {
  const t = Et(e);
  if (t.length % 16 !== 0) throw new Error("Invalid input length");
  const s = [];
  for (let n = 0; n < t.length; n += 16)
    s.push(Ct(t.slice(n, n + 16)));
  return s;
}, _t = (e) => new Promise((t) => setTimeout(t, e)), _ = class {
};
o(_, "down", "down");
o(_, "up", "up");
var M = class {
  constructor() {
    o(this, "id", B()), o(this, "myop", !0), o(this, "content"), o(this, "source"), o(this, "destination"), o(this, "route"), o(this, "ref"), o(this, "direction"), o(this, "cleanable", !1);
  }
  static create(...t) {
    return new this(...t);
  }
  isTypeof(t) {
    return t.messageType === this.messageType;
  }
}, bt = class extends M {
  constructor(e) {
    super(), this.ref = e;
  }
}, b = class extends M {
  constructor(e) {
    super(), this.replayToHandler = e;
  }
}, S = class extends M {
  constructor(t) {
    super(), this.handler = t, o(this, "handlerUniqueId", B());
  }
}, N = class ke {
  constructor(t, s) {
    this.refConfig = t, this.component = s, o(this, "myop", !0), o(this, "__nonProxied"), this.__nonProxied = W(w({}, this), {
      component: null
      // in order to be serializable
    });
  }
  static create(t, s, n) {
    let i = s;
    return i || (i = {
      id: "",
      name: "",
      description: "",
      selectorType: "id-attribute",
      selector: t,
      behavior: {
        type: "code"
      }
    }), new ke(i, n);
  }
}, De = "ClickReplayMessage", St = class extends S {
  constructor(e, t) {
    super(t), this.ref = e, o(this, "replyMessageKey", De), o(this, "messageType", "BindClickMessage"), o(this, "cleanable", !0);
  }
}, $e = class extends b {
  constructor() {
    super(...arguments), o(this, "messageType", De);
  }
}, It = class extends M {
  constructor(e, t) {
    super(), this.ref = e, o(this, "messageType", "ChangeTextMessage"), this.content = t;
  }
}, Le = "ExecuteScriptReplyMessage", Tt = /(?:function\s*\w*\s*\([^)]*\)\s*\{([\s\S]*?)\}|(\([^)]*\)\s*=>\s*\{([\s\S]*?)\}))\s*$/, xt = /\(\s*[^)]+\s*\)\s*=>\s*(.+)/, Oe = (e) => {
  let t = e.match(Tt);
  if (t)
    return t[1] || t[3];
  {
    let s = e.match(xt);
    if (s)
      return s[1].trim();
  }
}, k = class extends S {
  constructor(t, s = () => {
  }, n) {
    super(s), this.scriptInputs = n, o(this, "replyMessageKey", Le), o(this, "messageType", "ExecuteScriptMessage"), o(this, "script", ""), this.script = t.toString(), this.content = t.toString(), this.content = Oe(this.content);
  }
};
o(k, "replierKey", "send");
o(k, "completeStreamKey", "completeStream");
var Fe = class extends b {
  constructor(e, t) {
    super(e), this.replayToHandler = e, this.content = t, o(this, "messageType", Le);
  }
}, ne = class extends k {
  constructor(e, t, s = () => {
  }) {
    super(({ rootRef: n, elementId: i, _script: r, __scriptInputs: a }) => {
      const l = (n.shadowRoot || n.container).querySelectorAll(`[myop-id='${i}']`);
      return l.length ? (a.ref = l[0], new Function(`return (${r})(...arguments)`)(a)) : null;
    }, s), this.scriptInputs = t, this.scriptInputs = W(w({}, t), {
      //_script: stripFunction(script.toString()),
      _script: e.toString()
    });
  }
}, Be = "EventListenerCallbackMessage", Rt = class extends S {
  // {} // empty
  constructor(e, t, s) {
    super(s), this.ref = e, this.type = t, this.handler = s, o(this, "replyMessageKey", Be), o(this, "messageType", "AddEventListenerMessage"), o(this, "cleanable", !0), o(this, "serializableSkeleton", !1);
  }
  withSerializableSkeleton(e) {
    return this.serializableSkeleton = e, this;
  }
}, Pe = class extends b {
  constructor(e, t) {
    super(e), this.replayToHandler = e, this.e = t, o(this, "messageType", Be), this.content = {
      e: t
    };
  }
}, Ht = class extends M {
  constructor(e, t, s) {
    super(), this.ref = e, this.name = t, this.value = s, o(this, "messageType", "SetAttributeMessage");
  }
}, Ae = "ElementValueReplayMessage", kt = class extends S {
  constructor(e, t) {
    super(t), this.ref = e, o(this, "replyMessageKey", Ae), o(this, "messageType", "GetElementValueMessage");
  }
}, Ke = class extends b {
  constructor(e) {
    super(), this.content = e, o(this, "messageType", Ae);
  }
}, Dt = class extends M {
  constructor(e, t) {
    super(), this.ref = e, o(this, "messageType", "SetInnerHtml"), this.content = t;
  }
}, le = class extends M {
  constructor(e) {
    super(), o(this, "messageType", "InitMessage"), this.content = { id: e };
  }
  isTypeof(e) {
    return e.messageType === this.messageType;
  }
}, Ue = class extends le {
  constructor() {
    super(...arguments), o(this, "messageType", "InitResponse");
  }
}, Ne = class extends M {
  constructor() {
    super(...arguments), o(this, "messageType", "InitRequest");
  }
}, qe = "RefComponentCreatedMessage", Ve = class extends S {
  constructor(e, t, s, n) {
    super(n), this.refConfig = e, this.nestedComponentConfig = t, this.options = s, o(this, "replyMessageKey", qe), o(this, "messageType", "CreateRefComponentMessage");
  }
}, ie = class extends b {
  constructor(e, t, s) {
    super(e), this.replayToHandler = e, this.nestedRefs = t, this.failed = s, o(this, "messageType", qe);
  }
}, ze = class extends M {
  constructor(e, t) {
    super(), this.destination = e, this.message = t, o(this, "messageType", "EnvelopedMessage");
    const s = t;
    this.route = [e, ...s.route ? s.route : []];
  }
}, We = "DetectedMyopRefsMessage", $t = class extends S {
  constructor() {
    super(...arguments), o(this, "messageType", "DetectMyopRefsMessage"), o(this, "replyMessageKey", We);
  }
}, je = class extends b {
  constructor(e, t) {
    super(e), this.replayToHandler = e, o(this, "messageType", We), this.content = t;
  }
  isTypeof(e) {
    return e.messageType === this.messageType;
  }
}, Ge = "GetAttributeReplayMessage", Lt = class extends S {
  constructor(e, t, s) {
    super(s), this.ref = e, this.name = t, o(this, "replyMessageKey", Ge), o(this, "messageType", "GetAttributeMessage");
  }
}, Ot = class extends b {
  constructor(e) {
    super(), this.content = e, o(this, "messageType", Ge);
  }
}, R = class extends M {
  constructor(e) {
    super(), this.method = e, o(this, "messageType", "ExecuteComponentMethod");
  }
}, Ft = class extends M {
  constructor() {
    super(...arguments), o(this, "messageType", "SetMutationObserverMessage");
  }
}, Bt = class extends M {
  constructor() {
    super(...arguments), o(this, "messageType", "MutationObserverMessage");
  }
}, Ye = "CleanupReplayMessage", Je = class extends S {
  constructor(e, t) {
    super(t), this.cleanupForMessageId = e, o(this, "replyMessageKey", Ye), o(this, "messageType", "CleanupMessage");
  }
}, Ze = class extends b {
  constructor(e) {
    super(), this.customCleanup = e, o(this, "messageType", Ye);
  }
}, Xe = class extends M {
  constructor() {
    super(...arguments), o(this, "messageType", "DisposeMessage");
  }
}, Pt = class extends M {
  constructor() {
    super(...arguments), o(this, "cleanable", !0), o(this, "messageType", "SetResizeObserverMessage");
  }
}, At = class extends M {
  constructor() {
    super(...arguments), o(this, "messageType", "ResizeObserverMessage");
  }
}, ce = class {
  constructor(e, t, s) {
    this.componentDefinition = e, this.container = t, o(this, "id", ""), o(this, "messageHandlers", {}), o(this, "element"), o(this, "_markedForDisposed", !1), o(this, "bind", (i, r) => {
      this.messageHandlers[i] || (this.messageHandlers[i] = []), this.messageHandlers[i].includes(r) || this.messageHandlers[i].push(r);
    }), o(this, "bindWhen", (i, r, a) => {
      if (!a)
        throw new Error("can't use component.bindWhen without an handler");
      this.messageHandlers[i] || (this.messageHandlers[i] = []);
      const l = this.messageHandlers[i], c = (d) => r(d) ? (a(d), !0) : !1;
      return l.push(c), () => {
        const d = l.indexOf(c);
        d > -1 && l.splice(d, 1);
      };
    }), o(this, "setInitiated", () => {
      this.isInitiated = !0, this._whenInitiatedResolve && this._whenInitiatedResolve();
    }), o(this, "isInitiated", !1), o(this, "_whenInitiatedResolve"), o(this, "_whenInitiatedReject"), o(this, "_whenInitiated", new Promise((i, r) => {
      this._whenInitiatedResolve = i, this._whenInitiatedReject = r;
    })), o(this, "initiated", () => this._whenInitiated), o(this, "props", {}), o(this, "refs", {}), this.id = (s == null ? void 0 : s.id) || Z.Instance().assignId(e);
    const n = s != null && s.timeout ? s == null ? void 0 : s.timeout : 5 * 1e3;
    setTimeout(() => {
      !this.isInitiated && this._whenInitiatedReject && !this._markedForDisposed && this._whenInitiatedReject(`timeout_${n} ${this.id}`);
    }, n), this.initiated().then(() => {
      window.myop.hostSDK.inspected && this.inspect();
    });
  }
  get markedForDisposed() {
    return this._markedForDisposed;
  }
  set markedForDisposed(e) {
    if (this._markedForDisposed)
      throw new Error("InvalidOperationException: The component is already in the process of being disposed. Dispose operation cannot be performed again until the current disposal process is complete.");
    this._markedForDisposed = e;
  }
  onMessageReceived(e) {
    if (e.messageType === g.ExecuteComponentMethod) {
      const s = e;
      return this[s.method] ? this[s.method](s.content) : console.log(`method not found ${s.method} on component`, this), !0;
    }
    const t = this.messageHandlers[e.messageType];
    if (t && t.length) {
      let s = !1;
      return t.forEach((n) => {
        s = s || n(e);
      }), s;
    }
    return !1;
  }
  sendCleanupMessage(e) {
    e.source = this.id, e.destination = this.id, e.direction = _.down;
    const t = this.bindWhen(e.replyMessageKey, (n) => n.replayToHandler === e.handlerUniqueId, (n) => {
      e.handler(n), t();
    }), s = e.handler;
    delete e.handler, this.send(e), e.handler = s;
  }
  send(e) {
    e.source || (e.source = this.id), e.destination || (e.destination = this.id), e.direction = _.down;
    let t;
    if (e.handler) {
      const s = e;
      t = this.bindWhen(s.replyMessageKey, (n) => n.replayToHandler === s.handlerUniqueId, s.handler), delete e.handler;
    }
    return e.ref && (e.ref = e.ref.__nonProxied || e.ref), e.cleanable ? () => {
      this.sendCleanupMessage(new Je(e.id, (s) => {
      })), t && t();
    } : () => {
    };
  }
  dispose() {
    if (this.markedForDisposed = !0, !this.isInitiated)
      return;
    console.log("disposing component", this.id), this.send(new Xe());
    const e = this.messageHandlers.onDispose;
    e && e.forEach((t) => {
      t(null);
    }), this.messageHandlers = {}, this.id += "_disposed", this.isInitiated = !1;
  }
}, Kt = class {
  constructor(e, t, s, n, i) {
    this.myopId = e, this.htmlTagName = t, this.BoundingRect = s, this.offsetTop = n, this.offsetLeft = i, o(this, "type", "MyopElementRef");
  }
}, Ut = (e) => y(void 0, null, function* () {
  if (typeof e == "function")
    e();
  else if (e instanceof Promise) {
    const t = yield e;
    typeof t == "function" && t();
  }
}), Nt = class {
  //TODO : add dispose method
  constructor(e) {
    this.messageToHost = e;
  }
}, qt = class extends Nt {
  constructor(e, t) {
    super(e), this.messageToHost = e, this.context = t;
  }
}, Vt = class {
  //onMessageReceived: (msg: IMyopMessage) => void;
  constructor(e, t) {
    this.id = e, this.context = t, o(this, "send", (s) => {
    });
  }
}, zt = class {
  constructor() {
    o(this, "messageToHandleAfterInit", []), o(this, "components", {}), o(this, "alwaysPassEnvelopesToHost", !1), o(this, "messageCleanupCache", {});
  }
  handleIncomeMessages(e) {
    const t = e.data ? e.data : e.detail;
    if (!(!t || !t.myop)) {
      let s = t;
      if (s.direction !== _.down)
        return;
      if (s.messageType === g.DisposeMessage) {
        s.destination && delete this.components[s.destination];
        return;
      }
      if (s.messageType === g.InitMessage) {
        const n = s.content.id;
        if (this.components[n])
          return;
        this.components[n] = new Vt(n), this.messageToHost(new Ue(n));
        return;
      }
      if (s.messageType === g.EnvelopedMessage) {
        const n = s, i = n.message;
        if (s = i, this.alwaysPassEnvelopesToHost || this.components[s.destination]) {
          const r = myop.hostSDK.components.find((l) => l.id === i.destination);
          if (r) {
            r.send(i);
            return;
          }
          const a = myop.hostSDK.components.find((l) => l.id === n.destination);
          if (a) {
            a.send(i);
            return;
          }
        } else
          return;
      }
      if (s.messageType) {
        if (s.messageType === g.CleanupMessage) {
          const n = s, i = this.messageCleanupCache[n.cleanupForMessageId], r = new Ze(!!i);
          r.destination = s.destination, i ? (delete this.messageCleanupCache[n.cleanupForMessageId], Ut(i).then(() => {
            this.messageToHost(r, n);
          }).catch(() => {
          })) : this.messageToHost(r, n);
          return;
        }
        this.supportedHandlers.forEach((n) => {
          if (n.messageType === s.messageType) {
            const i = n.executor(s);
            if (s.cleanable && i && (this.messageCleanupCache[s.id] = i), i && !s.cleanable)
              throw new Error(`Cleanup handler generated for non-cleanable message. 
messageType - ${s.messageType}, handler executor was - ${n.executor}

Please review the message definition object & message handler.
To ensure cleanup properly set 'cleanable' true at message definition and return IMessageExecutorCleanup from your handlers.`);
            if (!i && s.cleanable)
              throw new Error(`No cleanup handler generated for a cleanable message. 
messageType - ${s.messageType}, handler executor was - ${n.executor}

Please review the message definition object & message handler.
To ensure cleanup properly set 'cleanable' true at message definition and return IMessageExecutorCleanup from your handlers.`);
          }
        });
      } else
        console.log("unsupported message type");
    }
  }
}, q = {
  IframeLoader: "IframeLoader",
  WebComponentLoader: "WebComponentLoader",
  HTMLLoader: "HTMLLoader"
}, V = {
  open: "open",
  none: "none",
  localFrame: "localFrame"
}, J = {
  code: "code"
}, de = class {
};
o(de, "code", "code");
o(de, "component", "component");
var U = {
  Segmented: "Segmented",
  Dedicated: "Dedicated",
  /**
   * This Selector Type is not yet supported but will be added in a future release.
   * Please check the documentation for updates.
   *
   * @type {string}
   */
  Default: "Default"
}, Qe = {
  Segment: "Segment",
  Promo: "Promo",
  AB: "AB"
}, Wt = class {
  constructor(e, t) {
    this.container = e, this.shadowRoot = t, o(this, "getRootDiv", () => (this.shadowRoot || this.container).querySelector("div")), o(this, "getRoot", () => this.shadowRoot || this.container);
  }
}, re = (e) => e !== Object(e), jt = (e) => typeof e == "function", et = (e) => {
  if (re(e))
    return !0;
  if (jt(e) || Object.getPrototypeOf(e))
    return !1;
  for (const t in e) {
    const s = e[t];
    if (typeof s == "object") {
      if (!et(s))
        return !1;
    } else {
      if (re(s))
        continue;
      return !1;
    }
  }
  return !0;
}, F = (e, t = {}, s = !0, n = /* @__PURE__ */ new WeakMap()) => {
  if (re(e))
    return e;
  if (Array.isArray(e)) {
    if (n.has(e))
      return n.get(e);
    const i = [];
    n.set(e, i);
    for (let r = 0; r < e.length; r++) {
      const a = e[r];
      i[r] = F(a, t, s, n);
    }
    return i;
  }
  if (e !== null && typeof e == "object") {
    if (n.has(e))
      return n.get(e);
    const i = {};
    n.set(e, i);
    for (const r in e) {
      const a = typeof t == "boolean" ? t : t[r];
      a && (a === !0 ? (s ? e[r] !== void 0 : e[r]) && (i[r] = F(e[r], !0, s, n)) : typeof a == "object" && (i[r] = F(e[r], a, s, n)));
    }
    return i;
  }
  return {};
}, Gt = {
  notSerializableRefCall: (e, t) => {
    throw new Error(`
The input provided to '${e.toString()}' is not serializable. Serialization is required to ensure that the data can be safely transferred to the skin implementation. 
The following types of data are considered non-serializable and cannot be processed:

- Functions
- DOM elements
- Class instances
- Circular references
- Symbols
- BigInt values

In the following execution we detected :
~~~~~~~~
${t} 
~~~~~~~~
as not serializable.

To resolve this issue, please ensure that all inputs passed to '${e.toString()}' are in a serializable format.
This typically includes primitive types (strings, numbers, booleans), arrays, and plain objects. 
If you need to include complex data types, consider converting them to a serializable structure before passing them to the function.
Or use Myop message that support it: CustomRefMessage, AddEventListenerMessage or ExecuteScriptMessage.

Suggested Fix:
1. Remove or replace non-serializable values from your input.
2. If using objects, ensure they do not contain any functions or circular references.
3. Convert any class instances to plain objects or JSON-compatible formats.
4. Use dedicated Myop message.

For more details on serialization and Myop message examples, refer to https://docs.myop.dev.

`);
  }
}, Me = class extends ce {
  constructor(e, t, s) {
    super(e, t.container, s), this.componentDefinition = e, this.parent = t, o(this, "send", (n) => {
      const i = n.handler, r = super.send(n);
      return this.parent.send(new ze(this.id, n)), n.handler = i, r;
    }), o(this, "dispose", () => {
      this.isInitiated && this.send(new R("dispose")), super.dispose();
    });
  }
  hide() {
    this.send(new R("hide"));
  }
  show() {
    this.send(new R("show"));
  }
  inspect() {
    return this.send(new R("inspect"));
  }
  setHeightBasedOnDocumentElement() {
    this.send(new R("setHeightBasedOnDocumentElement"));
  }
  setHeightBasedOnScrollHeight() {
    this.send(new R("setHeightBasedOnScrollHeight"));
  }
  onMessageReceived(e) {
    return super.onMessageReceived(e);
  }
}, Yt = (e, t, s) => {
  const n = document.createElement("a");
  return n.textContent = e, n.style.position = "relative", n.style.padding = "0 5px", n.style.fontSize = "14px", n.style.top = "0", n.style.top = `${t}px`, n.style.transform = "translateX(-50%)", n.target = "_blank", n.href = `https://dashboard.myop.dev/dashboard/component/${s.id}`, n;
}, tt = (e, t, s, n, i, r) => {
  const a = Yt(`${r.name} : ${t}`, s, r);
  return n.insertBefore(a, i), i.style.border = "1px solid #007BFF", i.style.display = "block", () => {
    i.style.border = "unset", n.removeChild(a);
  };
}, Ce = (e, t, s) => e ? !1 : (console.error(
  // throw new Error(
  `Error: Undefined Prop

It looks like you've tried to use a prop that hasn't been defined.
Please check the prop name for any typos or ensure that it is properly defined in the component's prop list.

Prop Name: ${t}
Component: ${s.componentDefinition.name}, ID: ${s.componentDefinition.id}

For more information, refer to the component page https://dashboard.myop.dev/dashboard/component/${s.componentDefinition.id} or consult the developer guide.`
), !0), Ee = (e, t, s) => {
  console.error(
    `Error: Code Prop Not Supported

Currently, code props are only supported in local frame components.
⚠️ This is a work in progress feature — code props will be supported in upcoming versions.

In the meantime, you can use message props.

Prop Name: ${t}
Component: ${s.componentDefinition.name}, ID: ${s.componentDefinition.id}

For more information, refer to the component page https://dashboard.myop.dev/dashboard/component/${s.componentDefinition.id} or consult the developer guide.`
  );
}, Jt = (e, t, s) => {
  const n = t.reduce((r, a) => W(w({}, r), {
    [a.name]: w({}, a)
  }), {}), i = {
    get: (r, a) => {
      const l = n[a];
      if (Ce(l, a, e))
        return !1;
      if (l.behavior.type === J.code) {
        if (s.loader.type === q.HTMLLoader && s.loader.shadowRootMode === V.localFrame) {
          const d = l.behavior;
          return e.element.contentWindow[d.remap || a];
        }
        return Ee(l, a, e), !1;
      }
      return l.mode === "output" ? new Promise((c) => {
        const d = [];
        l.behavior.ref && d.push(N.create(l.behavior.ref)), d.push((h) => {
          c(h);
        }), l.behavior.params && d.push(...l.behavior.params);
        const u = se[l.behavior.message];
        e.send(new u(...d));
      }) : null;
    },
    set: (r, a, l) => {
      const c = n[a];
      if (Ce(c, a, e))
        return !1;
      if (c.behavior.type === J.code) {
        if (s.loader.type === q.HTMLLoader && s.loader.shadowRootMode === V.localFrame) {
          const u = c.behavior;
          return e.element.contentWindow[u.remap || a] = l, !0;
        }
        return Ee(c, a, e), !1;
      } else if (c.mode === "input")
        if (c.behavior.type === "message") {
          const d = [];
          c.behavior.ref && d.push(N.create(c.behavior.ref)), d.push(l), c.behavior.params && d.push(...c.behavior.params);
          const u = se[c.behavior.message];
          return e.send(new u(...d)), !0;
        } else
          throw new Error(
            `Error: Unsupported Behavior

The 'behavior' field provided is not supported.
Component: ${e.componentDefinition.name}, ID: ${e.componentDefinition.id}

Prop Name: ${a}
Behavior Field: ${c.behavior.type}

Check the documentation for valid behavior options.`
          );
      return !1;
    }
  };
  return e.props = {}, e.props = new Proxy(e.props, i), e;
}, Zt = (e, t) => new Proxy(e, {
  get(s, n) {
    return s[n] ? s[n] : (...r) => new Promise((a) => {
      r.forEach((l) => {
        et(l) || Gt.notSerializableRefCall(n, l);
      }), t.send(new ne(
        ({ ref: l, propName: c, functionArgs: d, makeSerializable: u }) => {
          if (l) {
            const h = l[c];
            return u(typeof h == "function" ? l[c](...d) : h, !0);
          }
          return null;
        },
        {
          //TODO : turn it to config
          elementId: s.refConfig.selector,
          propName: n,
          functionArgs: r
        },
        (l) => {
          a(l.content);
        }
      ));
    });
  },
  set(s, n, i) {
    return t.send(new ne(
      ({ ref: r, propName: a, propValue: l }) => {
        r && (r[a] = l);
      },
      {
        //TODO : fix that
        elementId: s.refConfig.selector,
        propValue: i,
        propName: n
      },
      (r) => {
      }
    )), !0;
  }
}), st = (e, t, s, n) => y(void 0, null, function* () {
  const i = e.component;
  if (!i)
    throw new Error("cant createRefComponent with detached ref");
  return new Promise((r, a) => y(void 0, null, function* () {
    const l = new Me(t.type, i, n);
    s.push(l), yield i.initiated();
    const c = setTimeout(() => {
      a("timeout");
    }, 5e3);
    i.send(new Ve(
      e.refConfig,
      t,
      W(w({}, n || {}), {
        id: l.id,
        _hasParent: !0
      }),
      (d) => y(void 0, null, function* () {
        if (clearTimeout(c), d.failed) {
          a("CreateRefComponentMessage failed");
          return;
        }
        const u = s.find((h) => h.id == l.id);
        if (u !== l) {
          i.refs[e.refConfig.name] = u, r(u);
          return;
        } else
          l.setInitiated(), i.refs[e.refConfig.name] = l;
        d.nestedRefs.forEach((h) => {
          const m = t.instance.resolvedNestedComponents.find((v) => v.type.id === h.componentDefinitionId).type, f = new Me(m, l);
          f.setInitiated(), l.refs[h.refName] = f, s.push(f);
        });
        try {
          yield nt(l, t, s, !0), i.setHeightBasedOnScrollHeight && i.setHeightBasedOnScrollHeight(), r(l);
        } catch (h) {
          a(h);
        }
      })
    ));
  }));
}), nt = (e, t, s, n = !1) => y(void 0, null, function* () {
  e.refs || (e.refs = {});
  const i = Object.values(e.componentDefinition.refs).map((r) => new Promise((a, l) => y(void 0, null, function* () {
    var c;
    if (r.behavior.type == de.component) {
      if (n) {
        a();
        return;
      }
      let d = r.behavior.componentId;
      d || (d = r.behavior.instance.componentId);
      const u = (c = t.instance.resolvedNestedComponents) == null ? void 0 : c.find((m) => m.type.id === d);
      if (!u)
        throw new Error("componentConfig provided without nestedComponentConfig check the config object");
      const h = N.create("", r, e);
      try {
        const m = yield st(h, u, s);
        e.refs[r.name] = m, a();
      } catch (m) {
        l(m);
      }
    } else
      try {
        const d = N.create("", r, e);
        e.refs[r.name] = Zt(d, e), a();
      } catch {
      }
  })));
  try {
    yield Promise.all(i);
  } catch (r) {
    throw r;
  }
}), it = class extends ce {
  constructor(e, t, s, n, i) {
    super(e, s, i), this.componentConfig = e, this.container = s, this.IframeElement = n, o(this, "cleanupInspect"), o(this, "setHeightBasedOnDocumentElement", () => {
      const r = this.send(new k(() => window.document.documentElement.scrollHeight, (a) => {
        this.IframeElement.style.height = `${a.content}px`, r();
      }));
    }), o(this, "observeSizeBasedOnDocumentElement", () => this.send(new k(({ send: a }) => {
      const { height: l, width: c } = document.documentElement.getBoundingClientRect(), d = new ResizeObserver(() => {
        const { height: u, width: h } = document.documentElement.getBoundingClientRect();
        a({ height: u, width: h });
      });
      return d.observe(document.documentElement), d.observe(document.body), { height: l, width: c };
    }, (a) => {
      this.IframeElement.style.width = `${a.content.width}px`, this.IframeElement.style.height = `${a.content.height}px`;
    }))), o(this, "setSizeBasedOnDocumentElement", () => {
      const r = this.send(new k(() => {
        const { height: a, width: l } = document.documentElement.getBoundingClientRect();
        return { height: a, width: l };
      }, (a) => {
        this.IframeElement.style.width = `${a.content.width}px`, this.IframeElement.style.height = `${a.content.height}px`, r();
      }));
    }), o(this, "setHeightBasedOnScrollHeight", () => {
      const r = this.send(new k(() => {
        let l = 0;
        return l++, l--, Math.max(
          Math.max(
            window.document.body.clientHeight,
            window.document.body.scrollHeight
          ),
          window.document.body.offsetHeight
        ) + l + "px";
      }, (a) => {
        this.IframeElement.style.height = a.content, r();
      }));
    }), o(this, "send", (r) => {
      var a, l;
      let c = w({}, r);
      if (c.messageType === g.ExecuteComponentMethod)
        return this[c.method](), () => {
        };
      c.direction = _.down;
      const d = super.send(c);
      return (l = (a = this.IframeElement) == null ? void 0 : a.contentWindow) == null || l.postMessage(c, "*"), d;
    }), o(this, "dispose", () => {
      this.cleanupInspect && this.cleanupInspect(), super.dispose(), this.IframeElement.parentNode.removeChild(this.IframeElement);
    }), t.loader.autoHeight && this.initiated().then(() => {
      this.setHeightBasedOnScrollHeight();
    }), this.element = this.IframeElement;
  }
  inspect() {
    return this.cleanupInspect ? this.cleanupInspect : (this.cleanupInspect = tt(this.id, "MyopIframeComponent", 10, this.container, this.IframeElement, this.componentDefinition), () => {
      this.cleanupInspect(), this.cleanupInspect = void 0;
    });
  }
  hide() {
    this.IframeElement.style.opacity = "0", this.IframeElement.style.position = "absolute", this.IframeElement.style.pointerEvents = "none", this.IframeElement.style.visibility = "hidden";
  }
  show() {
    this.IframeElement.style.opacity = "1", this.IframeElement.style.position = "unset", this.IframeElement.style.pointerEvents = "all", this.IframeElement.style.visibility = "visible";
  }
  onMessageReceived(e) {
    return e.messageType === g.In.MutationObserverMessage || e.messageType === g.In.ResizeObserverMessage ? (this.setHeightBasedOnScrollHeight(), !0) : super.onMessageReceived(e);
  }
}, ue = class {
  constructor() {
    o(this, "appendChild", (e, t, s) => {
      var n;
      if (s != null && s.relative) {
        if (s.relative.direction === "before")
          return e.insertBefore(t, s.relative.child);
        if (s.relative.direction === "after") {
          const i = (n = s.relative.child) == null ? void 0 : n.nextSibling;
          return e.insertBefore(t, i || null);
        }
      } else
        return e.appendChild(t);
    });
  }
}, Xt = (e, t, s) => {
  const n = new URL(e);
  return n.searchParams.append(t, s), n.toString();
}, Qt = class extends ue {
  constructor() {
    super(...arguments), o(this, "type", q.IframeLoader), o(this, "load", (e, t, s, n) => y(this, null, function* () {
      let i;
      const r = t.loader;
      if ((s == null ? void 0 : s.nodeName) === "IFRAME")
        console.log("needs to load into an exsisting Iframe...", r.url, s), i = s, i.src = r.url;
      else {
        const a = B(), l = `myop-comp-${a}`;
        i = document.createElement("iframe"), s.querySelector('[id^="myop-comp-"]') || (s.innerHTML = ""), n != null && n.hidden && (i.style.visibility = "hidden"), i = this.appendChild(s, i, n);
        let c = t.loader.url;
        n != null && n._hasParent && (c = Xt(c, "_myop-comp", a));
        let d = "";
        n != null && n.elementAttributes && (d = Object.entries(n == null ? void 0 : n.elementAttributes).map(([u, h]) => h === "" || h === null || h === void 0 ? u : `${u}="${String(h)}"`).join(" ")), i.outerHTML = `<iframe 
               id="${l}"
               style="
                   padding: 0;
                   margin: 0;
                   height: ${r.autoHeight || !r.height ? "" : r.height};    
                   width : 100%;
                   overflow: hidden;
                   border: none;
                   opacity: ${n != null && n.hidden ? "0" : "1"};
                   position: ${n != null && n.hidden ? "absolute" : "static"};
                   pointer-events: ${n != null && n.hidden ? "none" : "all"};
               "
            src="${c}"
            ${d}
            ></iframe>`, i = s.querySelector(`#${l}`);
      }
      return new it(e, t, s, i, n);
    }));
  }
}, rt = {
  webcomponent_message_key: "myop_webcomponent_message"
}, ot = class extends ce {
  constructor(e, t, s, n, i) {
    super(e, s, i), this.container = s, this.customElement = n, o(this, "cleanupInspect", () => {
    }), o(this, "send", (r) => {
      let a = w({}, r);
      const l = super.send(a), c = new CustomEvent(rt.webcomponent_message_key, {
        // @ts-ignore
        detail: a
        // bubbles: true,
        // cancelable: false,
        // composed: true
      });
      try {
        this.customElement.dispatchEvent(c);
      } catch (d) {
        console.log("error while trying to dispatchEvent", d);
      }
      return l;
    }), o(this, "dispose", () => {
      var r;
      super.dispose(), (r = this.customElement.parentNode) == null || r.removeChild(this.customElement);
    }), this.element = n;
  }
  inspect() {
    return this.cleanupInspect = tt(this.id, "MyopWebComponent", 0, this.container, this.customElement, this.componentDefinition), this.cleanupInspect;
  }
  hide() {
    this.customElement.style.opacity = "0", this.customElement.style.position = "absolute", this.customElement.style.pointerEvents = "none", this.customElement.style.visibility = "hidden", this.customElement.style.height = "0", this.customElement.style.width = "0";
  }
  show() {
    this.customElement.style.opacity = "1", this.customElement.style.position = "unset", this.customElement.style.pointerEvents = "all", this.customElement.style.visibility = "visible", this.customElement.style.height = "", this.customElement.style.width = "";
  }
}, Q = {}, es = class extends ue {
  constructor() {
    super(...arguments), o(this, "type", q.WebComponentLoader), o(this, "load", (e, t, s, n) => y(this, null, function* () {
      const i = t.loader;
      Q[i.url] ? console.log("Module alreday loaded or in loading process") : Q[i.url] = new Promise((l, c) => {
        const d = i.url, u = document.createElement("script");
        u.type = "module", u.src = d, u.onload = () => {
          l();
        }, u.onerror = () => {
          c();
        }, document.head.appendChild(u);
      }), yield Q[i.url], yield _t(1);
      let r = `myop-comp-${B()}`;
      const a = document.createElement(i.tag);
      return s.querySelector('[id^="myop-comp-"]') || (s.innerHTML = ""), a.id = r, n != null && n.hidden && (a.style.opacity = "0", a.style.position = "absolute", a.style.height = "0", a.style.width = "0", a.style.pointerEvents = "none", a.style.visibility = "hidden"), n != null && n._environment && (a._myopEnvironment = n == null ? void 0 : n._environment), this.appendChild(s, a, n), new ot(e, t, s, a, n);
    }));
  }
}, ts = "0.2.6", I = class extends qt {
  constructor(e, t) {
    super(e), this.context = t, o(this, "executor", (s) => {
      if (s.destination) {
        const n = s.destination;
        if (this.context[n].context) {
          const i = (r, a) => {
            this.messageToHost(W(w({}, r), {
              source: s.destination ? s.destination : s.source,
              destination: s.source ? s.source : s.destination
            }), a);
          };
          return this.innerExecutor(s, this.context[n].context, i);
        } else
          debugger;
      } else
        debugger;
    });
  }
}, z = {
  id: "myop-id"
}, P = (e, t) => t.querySelectorAll(`[${z.id}='${e.refConfig.selector}']`), ss = class extends I {
  constructor() {
    super(...arguments), o(this, "messageType", g.BindClickMessage), o(this, "innerExecutor", (e, t, s) => {
      const n = P(e.ref, t.shadowRoot), i = [];
      return n.forEach((r) => {
        const a = () => {
          s(new $e(e.handlerUniqueId));
        };
        r.addEventListener("click", a), i.push(() => {
          r.removeEventListener("click", a);
        });
      }), () => {
        i.forEach((r) => r());
      };
    });
  }
}, ns = class extends I {
  constructor() {
    super(...arguments), o(this, "messageType", g.ChangeTextMessage), o(this, "innerExecutor", (e, t) => {
      P(e.ref, t.shadowRoot).forEach((n) => {
        n.textContent = e.content;
      });
    });
  }
}, is = class extends Wt {
  constructor(e, t) {
    super(e, t), this.container = e, this.shadowRoot = t;
  }
}, rs = class extends I {
  constructor() {
    super(...arguments), o(this, "innerExecutor", (e, t) => {
      const s = t.shadowRoot.querySelectorAll(`[${z.id}]`);
      let n = [];
      s.forEach((i) => {
        const r = i.getAttribute(z.id);
        r && n.push(new Kt(r, i.tagName, i.getBoundingClientRect(), i.offsetTop, i.offsetLeft));
      }), this.messageToHost(new je(e.handlerUniqueId, n));
    }), o(this, "messageType", g.DetectMyopRefsMessage);
  }
}, os = class extends I {
  constructor() {
    super(...arguments), o(this, "messageType", g.SetAttributeMessage), o(this, "innerExecutor", (e, t) => {
      P(e.ref, t.shadowRoot).forEach((n) => {
        n.setAttribute(e.name, e.value);
      });
    });
  }
}, as = class extends I {
  constructor() {
    super(...arguments), o(this, "messageType", g.AddEventListenerMessage), o(this, "innerExecutor", (e, t, s) => {
      const n = P(e.ref, t.shadowRoot), i = [];
      return n.forEach((r) => {
        const a = (l) => {
          s(new Pe(e.handlerUniqueId, F(l, e.serializableSkeleton)));
        };
        r.addEventListener(e.type, a), i.push(() => {
          r.removeEventListener(e.type, a);
        });
      }), () => {
        i.forEach((r) => r());
      };
    });
  }
}, ls = class extends I {
  constructor() {
    super(...arguments), o(this, "messageType", g.CreateRefComponentMessage), o(this, "innerExecutor", (e, t, s) => {
      y(this, null, function* () {
        const i = t.shadowRoot.querySelectorAll(`[${z.id}='${e.refConfig.selector}']`);
        if (i.length === 1) {
          const r = Z.Instance(), a = r.components.find((u) => u.id === e.options.id);
          a && a.dispose();
          const l = r.components.indexOf(a);
          l !== -1 && r.components.splice(l, 1);
          const c = yield r.loadComponent(
            e.nestedComponentConfig,
            i.item(0),
            e.options
          ), d = [];
          Object.keys(c.refs).forEach((u) => {
            let h = c.refs[u];
            h = h.__nonProxied || h, h.componentDefinition && d.push({
              refName: u,
              componentDefinitionId: h.componentDefinition.id
            });
          }), s(new ie(e.handlerUniqueId, d));
        } else {
          console.error("CreateRefComponentMessageHandler - DOM element not found"), this.messageToHost(new ie(e.handlerUniqueId, [], !0));
          debugger;
        }
      }).then();
    });
  }
}, cs = (e, t, s) => {
  const n = e.scriptInputs ? e.scriptInputs : {};
  n.makeSerializable = F, n.send = t, n.rootRef = s, n.__scriptInputs = n;
  const r = new Function(`return (${e.script})(...arguments)`)(n);
  t(r);
}, ds = class extends I {
  constructor() {
    super(...arguments), o(this, "messageType", g.ExecuteScriptMessage), o(this, "innerExecutor", (e, t, s) => {
      cs(e, (i) => {
        s(new Fe(e.handlerUniqueId, i));
      }, t);
    });
  }
}, at = (e) => {
  if (!e) return null;
  if (e.tagName === "FORM") {
    new FormData(e);
    const t = {
      formData: {},
      unmappedData: []
    };
    return e.querySelectorAll("input, select, textarea").forEach((n) => {
      if (typeof n.value == "string") {
        const i = n.getAttribute(z.id);
        let r = n.getAttribute("name");
        const a = {
          id: n.id,
          name: r,
          value: at(n),
          required: n.required,
          validity: F(n.validity, !0),
          myopId: i
        };
        r ? t.formData[r] ? t.formData[r].value ? t.unmappedData.push(a) : (t.unmappedData.push(t.formData[r]), t.formData[r] = a) : t.formData[r] = a : t.unmappedData.push(a);
      }
    }), t;
  }
  return e.type === "checkbox" || e.type === "radio" ? e.checked ? e.value : null : e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.tagName === "SELECT" ? e.value : e.isContentEditable ? e.innerText || e.textContent : null;
}, us = class extends I {
  constructor() {
    super(...arguments), o(this, "messageType", g.GetElementValueMessage), o(this, "innerExecutor", (e, t, s) => {
      P(e.ref, t.shadowRoot).forEach((i) => {
        s(new Ke(at(i)), e);
      });
    });
  }
}, hs = class extends I {
  constructor() {
    super(...arguments), o(this, "messageType", g.SetInnerHtml), o(this, "innerExecutor", (e, t) => {
      P(e.ref, t.shadowRoot).forEach((n) => {
        n.innerHTML = e.content;
      });
    });
  }
}, lt = class extends zt {
  constructor() {
    super(...arguments), o(this, "alwaysPassEnvelopesToHost", !0), o(this, "connectedCallback", (e, t) => {
      e.addEventListener(rt.webcomponent_message_key, (s) => {
        const n = s.data ? s.data : s.detail;
        if (!n || !n.myop) {
          debugger;
          throw new Error("recvied webcomponent_message with wrong type");
        } else {
          const i = n;
          if (this.handleIncomeMessages(s), i.messageType === g.InitMessage) {
            const r = i.content.id;
            this.components[r].context = new is(e, t);
          }
        }
      }), setTimeout(() => {
        this.messageToHost(new Ne());
      }, 1);
    }), o(this, "messageToHost", (e, t) => {
      e.direction = _.up, !e.replayToHandler && (t != null && t.handlerUniqueId) && (e.replayToHandler = t.handlerUniqueId), window.myop.hostSDK.send(e);
    }), o(this, "supportedHandlers", [
      new ns(this.messageToHost, this.components),
      new hs(this.messageToHost, this.components),
      new ss(this.messageToHost, this.components),
      new rs(this.messageToHost, this.components),
      new os(this.messageToHost, this.components),
      new as(this.messageToHost, this.components),
      new ds(this.messageToHost, this.components),
      new us(this.messageToHost, this.components),
      //
      new ls(this.messageToHost, this.components)
    ]), o(this, "init", () => {
    });
  }
};
He("WebComponentSDK", lt);
var _e = [], Y, ct = () => y(void 0, null, function* () {
  return Y || (Y = new lt(), Y.init()), Y;
});
function ps(e, t) {
  return class extends HTMLElement {
    connectedCallback() {
      const s = t === V.open ? "open" : "closed", n = this.attachShadow({ mode: s });
      ct().then((i) => {
        i.connectedCallback(this, n), n.innerHTML = e;
      });
    }
  };
}
var ms = (e, t, s) => {
  customElements.define(e, ps(t, s)), console.log(`define('${e}') was called, web component ready to use`);
}, fs = (e) => e.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/(\d+)/g, "-$1").toLowerCase(), ys = (e) => (e = fs(e), e.replace(/_/g, "-")), gs = class extends ue {
  constructor() {
    super(...arguments), o(this, "type", q.HTMLLoader), o(this, "load", (e, t, s, n) => y(this, null, function* () {
      const i = t.loader;
      let r = `myop-comp-${B()}`, a;
      if (i.shadowRootMode === V.localFrame) {
        const c = `myop-comp-${B()}`;
        let d = document.createElement("iframe");
        s.querySelector('[id^="myop-comp-"]') || (s.innerHTML = ""), n != null && n.hidden && (d.style.visibility = "hidden"), d = this.appendChild(s, d, n), d.id = c, d.setAttribute("style", `
                   display: block;
                   padding: 0;
                   margin: 0;
                   overflow: hidden;
                   border: none;
                   opacity: ${n != null && n.hidden ? "0" : "1"};
                   width: 100%;
                   height: 100%;
                   position: ${n != null && n.hidden ? "absolute" : "static"};
                   pointer-events: ${n != null && n.hidden ? "none" : "all"};
               `), s.appendChild(d);
        const u = d.contentDocument || d.contentWindow.document;
        u.open();
        let h = i.HTML;
        if (n != null && n._inspection) {
          const v = new DOMParser().parseFromString(i.HTML, "text/html"), O = v.getElementById("myop_preview");
          O == null || O.removeAttribute("type");
          const A = v.implementation.createHTMLDocument();
          A.body.innerHTML = `<script>
                        const beforeKeysWindow = new Set(Object.keys(window));
                        window.myopState = {
                            beforeKeysWindow,
                        };
                <\/script>`;
          const C = A.body.firstChild;
          C && v.head && v.head.insertBefore(v.importNode(C, !0), v.head.firstChild), h = v.documentElement.outerHTML;
        }
        u.writeln(h), u.writeln(`<script src="${window.myop.__ROOT_SDK_PUBLIC_URL__}"><\/script>
                    <script>
                  
                   window.__federation__.__public_path__ =  window.__federation__.__public_path__;
                  
                   const __myop_init = async () => {
                        const {IframeSDK} = (await window.myop.rootSDK.getIframeModule());
                        const sdk = new IframeSDK()
                        sdk.init();
                   }
                    
                   __myop_init().then();
                    
              <\/script>`), u.close();
        const m = new it(e, t, s, d, n);
        return i.autoHeight && (d.onload = () => {
          m.observeSizeBasedOnDocumentElement();
        }), m;
      }
      if (i.shadowRootMode === V.none) {
        const l = document.createElement("template");
        l.innerHTML = i.HTML, a = l.content.firstElementChild, ct().then((c) => {
          c.connectedCallback(a, a);
        });
      } else {
        const l = ys(e.name + t.id);
        _e.includes(l) || (ms(l, i.HTML, i.shadowRootMode), _e.push(l)), a = document.createElement(l);
      }
      return s.querySelector('[id^="myop-comp-"]') || (s.innerHTML = ""), a.id = r, n != null && n.hidden && (a.style.opacity = "0", a.style.position = "absolute", a.style.height = "0", a.style.width = "0", a.style.pointerEvents = "none", a.style.visibility = "hidden"), this.appendChild(s, a, n), new ot(e, t, s, a, n);
    }));
  }
}, vs = (e) => ({
  instance: {
    id: "auto",
    componentId: e.componentId,
    componentName: e.name,
    skinSelector: {
      type: "Dedicated",
      skin: {
        id: "skin_auto_v2_converted"
      }
    }
  },
  type: {
    id: e.id,
    name: e.name,
    description: e.description,
    props: [
      {
        id: "in_auto_v2_converted",
        name: "myop_init_interface",
        type: "any",
        behavior: {
          type: J.code
        }
      },
      {
        id: "out_auto_v2_converted",
        name: "myop_cta_handler",
        type: "any",
        behavior: {
          type: J.code
        }
      }
    ],
    refs: [],
    skins: [
      {
        id: "skin_auto_v2_converted",
        name: "auto_v2_converted",
        description: "",
        //TODO : handle empty :
        // @ts-ignore
        loader: e.consume_variant[0].loader
      }
    ],
    defaultSkin: 0
  },
  name: e.name
}), oe = class {
  constructor(t = "https://cloud.myop.dev") {
    this._baseUrl = t, o(this, "variants", {}), o(this, "userFlows", {}), o(this, "_defaultEnv", "production");
  }
  /**
   * Set the default environment for this CloudRepository instance
   */
  setEnvironment(t) {
    this._defaultEnv = t;
  }
  /**
   * Get the current default environment
   */
  getDefaultEnvironment() {
    return this._defaultEnv;
  }
  // ============ V2 Methods (Default) ============
  /**
   * Check if a component is already cached/preloaded (v2)
   */
  isPreloaded(t, s, n) {
    return `${t}:${s || this._defaultEnv}:${n ? "preview" : "live"}` in this.variants;
  }
  /**
   * Fetch a v2 component config
   */
  fetchComponentV2(t, s, n) {
    return y(this, null, function* () {
      const i = s || this._defaultEnv, r = `${t}:${i}:${n ? "preview" : "live"}`;
      return this.variants[r] || (this.variants[r] = new Promise(
        (a, l) => y(this, null, function* () {
          try {
            let c = `${this._baseUrl}/consume?id=${t}&env=${i}`;
            n && (c += "&preview=true");
            const h = (yield (yield fetch(c)).json()).item;
            if (!h) {
              l(new Error(`Component "${t}" not found`));
              return;
            }
            if (!h.consume_variant || !h.consume_variant.length) {
              l(new Error(`Component "${t}" has no implementation for environment "${i}"`));
              return;
            }
            const m = vs(h);
            a(m);
          } catch (c) {
            l(c);
          }
        })
      )), yield this.variants[r];
    });
  }
  // ============ V1 Methods (Legacy) ============
  /**
   * Fetch a v1 component from a flow
   */
  fetchComponentV1(t, s) {
    return y(this, null, function* () {
      return s ? (yield this.fetchFlow(s)).components.find((i) => i.type.id === t) : (yield this.fetchAutoFlow(t)).components[0];
    });
  }
  fetchAutoFlow(t) {
    return y(this, null, function* () {
      return this.userFlows[t] || (this.userFlows[t] = new Promise(
        (s, n) => y(this, null, function* () {
          try {
            const r = yield (yield fetch(
              `${this._baseUrl}/flow?id=${t}&auto=true`
            )).json();
            s(r.item);
          } catch (i) {
            n(i);
          }
        })
      )), yield this.userFlows[t];
    });
  }
  fetchFlow(t) {
    return y(this, null, function* () {
      return this.userFlows[t] || (this.userFlows[t] = new Promise(
        (s, n) => y(this, null, function* () {
          try {
            const r = yield (yield fetch(
              `${this._baseUrl}/flow?id=${t}&resolve=components`
            )).json();
            s(r.item);
          } catch (i) {
            n(i);
          }
        })
      )), yield this.userFlows[t];
    });
  }
  // ============ Backward Compatibility ============
  /**
   * @deprecated Use fetchComponentV2 or fetchComponentV1 explicitly
   * Defaults to v1 behavior for backward compatibility with existing code
   */
  fetchComponent(t, s) {
    return y(this, null, function* () {
      return this.fetchComponentV1(t, s);
    });
  }
};
o(oe, "Main", new oe());
var be = oe, ws = (e) => y(void 0, null, function* () {
  try {
    const t = new URL(window.location.href), n = new URLSearchParams(t.search).get("myopOverride");
    if (n) {
      const [i, ...r] = we(n);
      switch (i) {
        case "component":
          {
            const [a, l] = r, c = yield be.Main.fetchComponent(a);
            if (c && c.type.skins.find((u) => u.id === l))
              return c.instance.skinSelector = {
                type: U.Dedicated,
                skin: {
                  id: l
                }
              }, c;
          }
          break;
        //    case 'flow': {
        default:
          {
            const [a, l] = we(n), d = (yield be.Main.fetchFlow(a)).components.find((u) => u.type.id === e.type.id);
            if (d && d.instance.skinSelector.type === U.Segmented && d.instance.resolvedExperiences) {
              const u = d.instance.resolvedExperiences.find((h) => h.id === l);
              if ((u == null ? void 0 : u.type) === Qe.Segment) {
                const h = u, f = d.instance.skinSelector.segments.find((v) => v.segmentId === h.segment.id);
                if (f)
                  return d.instance.skinSelector = f == null ? void 0 : f.skinSelector, d;
              }
            }
          }
          break;
      }
    }
  } finally {
    return null;
  }
}), dt = "https://cdn.myop.dev/sdk/next/myop_sdk.min.js", Z = class {
  constructor() {
    o(this, "components2init", []), o(this, "components", []), o(this, "componentsLoaders", []), o(this, "initiated", !1), o(this, "version", ts), o(this, "type2InstanceCount", {}), o(this, "assignId", (e) => (this.type2InstanceCount[e.id] || (this.type2InstanceCount[e.id] = 0), `${e.id}_${++this.type2InstanceCount[e.id]}`)), o(this, "inspected", !1), o(this, "inspect", () => {
      this.inspected || (this.inspected = !0, this.components.forEach((e) => {
        e.inspect && e.inspect();
      }));
    }), o(this, "incomingMessageHandler", (e) => {
      if (e.origin, document.location.origin, e.data.myop) {
        if (e.data.direction !== _.up && e.data.messageType !== g.EnvelopedMessage)
          return;
        const t = e.data;
        if (t.messageType === g.InitRequest) {
          this.components2init.forEach((n) => {
            n.send(new le(n.id));
          });
          return;
        }
        if (t.messageType === g.InitResponse) {
          this.components2init = this.components2init.filter((i) => i.id !== t.content.id);
          const n = this.components.find((i) => {
            var r;
            return i.id === ((r = t.content) == null ? void 0 : r.id);
          });
          n == null || n.setInitiated();
          return;
        }
        if (t.messageType === g.EnvelopedMessage) {
          const n = t, i = this.components.find((r) => r.id === n.destination);
          if (i) {
            if (n.direction === _.down) {
              n.message.messageType === R.name ? i.onMessageReceived(n.message) : (n.message.route = n.route, i.send(n.message));
              return;
            }
          } else {
            const r = this.components.find((a) => a.id === n.message.destination);
            r && r.send(n.message);
          }
          return;
        }
        const s = this.components.find((n) => n.id === t.destination);
        if (!s) {
          window.myop.IframeSDK && window.myop.IframeSDK.messageToHost(t);
          return;
        }
        if (s) {
          if (s.onMessageReceived(t))
            return;
          window.myop.IframeSDK && window.myop.IframeSDK.messageToHost(t);
        }
      }
    }), o(this, "send", (e) => {
      const t = new MessageEvent(
        "",
        { data: e }
      );
      this.incomingMessageHandler(t);
    }), o(this, "init", (e) => {
      if (this.initiated)
        throw new Error("hostSDK already initiated");
      const t = [
        new Qt(),
        new es(),
        new gs()
      ];
      if (this.componentsLoaders = [
        ...t
      ], e) {
        const s = {};
        e.forEach((n) => {
          const i = new n(this.componentsLoaders);
          s[i.type] = i;
        }), this.componentsLoaders.forEach((n) => {
          s[n.type] || (s[n.type] = n);
        }), this.componentsLoaders = Object.values(s);
      }
      window.addEventListener(
        "message",
        this.incomingMessageHandler,
        !1
      ), console.log("myop hostSDK initiated", document.location.href), this.initiated = !0;
    }), o(this, "_getSkinIdBySkinSelector", (e, ...t) => y(this, [e, ...t], function* (s, n = [], i) {
      var r;
      function a(l, c) {
        return y(this, null, function* () {
          for (const d of l)
            if (yield c(d))
              return d;
        });
      }
      switch (s.type) {
        // @ts-ignore
        case "DedicatedSkin":
        //backward compatibility
        case U.Dedicated:
          return ((r = s.skin) == null ? void 0 : r.id) || s.skins[0].id;
        case U.Segmented:
          {
            const c = yield a(s.segments, (d) => y(this, null, function* () {
              if (d.segmentId === "Default")
                return !0;
              const u = n.find((v) => v.type === Qe.Segment ? v.segment.id === d.segmentId : !1);
              if (!u)
                throw new Error("experience not found");
              const m = u.segment, f = (i || {})[m.function];
              return f ? yield f() : (console.warn(`segmentId:${d.segmentId}, ${m.function} function not provided !`), !1);
            }));
            if (c)
              return this._getSkinIdBySkinSelector(c.skinSelector, n);
            debugger;
          }
          break;
        default:
          debugger;
      }
      return "";
    })), o(this, "runSkinSelector", (e, t) => y(this, null, function* () {
      const s = yield this._getSkinIdBySkinSelector(e.instance.skinSelector, e.instance.resolvedExperiences, t);
      return e.type.skins.find((n) => n.id === s);
    })), o(this, "loaderHooks"), o(this, "loadComponent", (e, t, s) => y(this, null, function* () {
      var n, i, r, a;
      if (!t) {
        debugger;
        throw new Error("no container was found for this component");
      }
      const l = yield ws(e);
      l && (e = l);
      const c = w(w({}, (n = this.loaderHooks) != null ? n : {}), (i = s == null ? void 0 : s.hooks) != null ? i : {}), d = t;
      if (d.myop)
        if (d.component) {
          e = w({}, e), e.instance = w({}, e.instance);
          let f = yield this.runSkinSelector(e, c);
          if (!f)
            throw new Error("runSkinSelector failed to choose skin, check the provided config");
          return (r = s == null ? void 0 : s.hooks) != null && r.afterSkinSelected && (f = yield s.hooks.afterSkinSelected(w({}, f))), e.instance.skinSelector = {
            type: U.Dedicated,
            skin: f
            //  skins: [selectedSkin]
          }, s && (s = w({}, s), delete s.hooks), yield st(d, e, this.components, s);
        } else
          throw new Error("load component got a detached ref.");
      t = t;
      let u = yield this.runSkinSelector(e, c);
      if (!u)
        throw new Error("runSkinSelector failed to choose skin, check the provided config");
      (a = s == null ? void 0 : s.hooks) != null && a.afterSkinSelected && (u = yield s.hooks.afterSkinSelected(w({}, u)));
      const h = this.componentsLoaders.find((f) => f.type === u.loader.type);
      if (!h) {
        debugger;
        throw new Error(`no loader "${u.loader.type}" was found for component`);
      }
      let m = yield h.load(e.type, u, t, s);
      m.isInitiated || this.components2init.push(m), m.bind("onDispose", () => (this.components = this.components.filter((f) => f !== m), this.components2init = this.components2init.filter((f) => f !== m), !0)), this.components.push(m), (!s || s.connectProps !== !1) && (m = Jt(m, e.type.props, u));
      try {
        yield nt(m, e, this.components);
      } catch (f) {
        throw f;
      }
      return s != null && s.skipInit || (yield m.initiated()), m;
    })), o(this, "navigate", (e, t, s) => y(this, null, function* () {
      if (e.parent)
        throw new Error("Navigating on remote ref components is not implemented yet");
      if (s != null && s.staged) {
        let n = yield this.loadComponent(t, e.container, w({
          hidden: !0,
          relative: { direction: "after", child: e.element }
        }, s));
        return s.init && (yield s.init(n)), n.show(), e.dispose(), n;
      } else {
        const n = e.element.nextSibling;
        return e.dispose(), this.loadComponent(t, e.container, w({
          relative: {
            direction: "before",
            child: n
          }
        }, s));
      }
    }));
  }
};
o(Z, "Instance", () => window.myop.hostSDK);
window.myop || (window.myop = {
  __ROOT_SDK_PUBLIC_URL__: dt
});
if (!window.myop.hostSDK) {
  const e = new Z();
  e.init(), window.myop || (window.myop = {
    __ROOT_SDK_PUBLIC_URL__: dt
  }), window.myop.hostSDK = e;
}
var he = window.myop.hostSDK;
He("hostSDK", he);
var Ms = Object.defineProperty, Cs = (e, t, s) => t in e ? Ms(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, p = (e, t, s) => Cs(e, typeof t != "symbol" ? t + "" : t, s), x = (e, t, s) => new Promise((n, i) => {
  var r = (c) => {
    try {
      l(s.next(c));
    } catch (d) {
      i(d);
    }
  }, a = (c) => {
    try {
      l(s.throw(c));
    } catch (d) {
      i(d);
    }
  }, l = (c) => c.done ? n(c.value) : Promise.resolve(c.value).then(r, a);
  l((s = s.apply(e, t)).next());
}), D = () => "10000000-1000-4000-8000-100000000000".replace(
  /[018]/g,
  (e) => (+e ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +e / 4).toString(16)
), Es = class {
  constructor() {
    p(this, "id", D()), p(this, "myop", !0), p(this, "content"), p(this, "source"), p(this, "destination"), p(this, "route"), p(this, "ref"), p(this, "direction"), p(this, "cleanable", !1);
  }
  static create(...e) {
    return new this(...e);
  }
  isTypeof(e) {
    return e.messageType === this.messageType;
  }
}, _s = class extends Es {
  constructor(e) {
    super(), this.handler = e, p(this, "handlerUniqueId", D());
  }
}, bs = "ExecuteScriptReplyMessage", Ss = /(?:function\s*\w*\s*\([^)]*\)\s*\{([\s\S]*?)\}|(\([^)]*\)\s*=>\s*\{([\s\S]*?)\}))\s*$/, Is = /\(\s*[^)]+\s*\)\s*=>\s*(.+)/, Ts = (e) => {
  let t = e.match(Ss);
  if (t)
    return t[1] || t[3];
  {
    let s = e.match(Is);
    if (s)
      return s[1].trim();
  }
}, ut = class extends _s {
  constructor(e, t = () => {
  }, s) {
    super(t), this.scriptInputs = s, p(this, "replyMessageKey", bs), p(this, "messageType", "ExecuteScriptMessage"), p(this, "script", ""), this.script = e.toString(), this.content = e.toString(), this.content = Ts(this.content);
  }
};
p(ut, "replierKey", "send");
p(ut, "completeStreamKey", "completeStream");
var Se = class {
  constructor() {
    p(this, "_runTimeInstanceId", "runtime-instance-id-" + D()), p(this, "_runTimeId", "runtime-id-" + D()), p(this, "_runTimeName", "runtime-name-" + D()), p(this, "id", this._runTimeId), p(this, "name", this._runTimeName), p(this, "description", ""), p(this, "loader", null), p(this, "withLoader", (t) => (this.loader = t, this)), p(this, "withHTMLLoader", (t) => (t.type = "HTMLLoader", this.loader = t, this)), p(this, "build", () => this);
  }
};
p(Se, "create", () => new Se());
var Ie = class {
  constructor() {
    p(this, "_runTimeInstanceId", "runtime-instance-id-" + D()), p(this, "_runTimeId", "runtime-id-" + D()), p(this, "_runTimeName", "runtime-name-" + D()), p(this, "instance", {
      id: this._runTimeInstanceId,
      componentId: this._runTimeId,
      componentName: this._runTimeName,
      skinSelector: null
    }), p(this, "name", this._runTimeName), p(this, "type", {
      id: this._runTimeId,
      name: this._runTimeName,
      description: "",
      props: [],
      refs: [],
      skins: [],
      defaultSkin: 0
    }), p(this, "withInstance", (t) => (this.instance = t, this)), p(this, "withType", (t) => (this.type = t, this)), p(this, "withName", (t) => (this.name = t, this)), p(this, "withDefaultSkin", (t) => (this.type.skins.push(t), this.type.defaultSkin = this.type.skins.length - 1, this.instance.skinSelector = {
      type: "Dedicated",
      skin: {
        id: t.id
      }
    }, this)), p(this, "withRef", (t) => (this.type.refs.push(t), this)), p(this, "withBasicRef", (t) => {
      const s = {
        id: "",
        name: t,
        description: "",
        selectorType: "id-attribute",
        selector: t,
        behavior: {
          type: "code"
        }
      };
      return this.type.refs.push(s), this;
    }), p(this, "build", () => JSON.parse(JSON.stringify(this)));
  }
};
p(Ie, "create", () => new Ie());
var Te = {
  code: "code"
}, xs = (e) => ({
  instance: {
    id: "auto",
    componentId: e.componentId,
    componentName: e.name,
    skinSelector: {
      type: "Dedicated",
      skin: {
        id: "skin_auto_v2_converted"
      }
    }
  },
  type: {
    id: e.id,
    name: e.name,
    description: e.description,
    props: [
      {
        id: "in_auto_v2_converted",
        name: "myop_init_interface",
        type: "any",
        behavior: {
          type: Te.code
        }
      },
      {
        id: "out_auto_v2_converted",
        name: "myop_cta_handler",
        type: "any",
        behavior: {
          type: Te.code
        }
      }
    ],
    refs: [],
    skins: [
      {
        id: "skin_auto_v2_converted",
        name: "auto_v2_converted",
        description: "",
        //TODO : handle empty :
        // @ts-ignore
        loader: e.consume_variant[0].loader
      }
    ],
    defaultSkin: 0
  },
  name: e.name
}), ae = class {
  constructor(t = "https://cloud.myop.dev") {
    this._baseUrl = t, p(this, "variants", {}), p(this, "userFlows", {}), p(this, "_defaultEnv", "production");
  }
  /**
   * Set the default environment for this CloudRepository instance
   */
  setEnvironment(t) {
    this._defaultEnv = t;
  }
  /**
   * Get the current default environment
   */
  getDefaultEnvironment() {
    return this._defaultEnv;
  }
  // ============ V2 Methods (Default) ============
  /**
   * Check if a component is already cached/preloaded (v2)
   */
  isPreloaded(t, s, n) {
    return `${t}:${s || this._defaultEnv}:${n ? "preview" : "live"}` in this.variants;
  }
  /**
   * Fetch a v2 component config
   */
  fetchComponentV2(t, s, n) {
    return x(this, null, function* () {
      const i = s || this._defaultEnv, r = `${t}:${i}:${n ? "preview" : "live"}`;
      return this.variants[r] || (this.variants[r] = new Promise(
        (a, l) => x(this, null, function* () {
          try {
            let c = `${this._baseUrl}/consume?id=${t}&env=${i}`;
            n && (c += "&preview=true");
            const h = (yield (yield fetch(c)).json()).item;
            if (!h) {
              l(new Error(`Component "${t}" not found`));
              return;
            }
            if (!h.consume_variant || !h.consume_variant.length) {
              l(new Error(`Component "${t}" has no implementation for environment "${i}"`));
              return;
            }
            const m = xs(h);
            a(m);
          } catch (c) {
            l(c);
          }
        })
      )), yield this.variants[r];
    });
  }
  // ============ V1 Methods (Legacy) ============
  /**
   * Fetch a v1 component from a flow
   */
  fetchComponentV1(t, s) {
    return x(this, null, function* () {
      return s ? (yield this.fetchFlow(s)).components.find((i) => i.type.id === t) : (yield this.fetchAutoFlow(t)).components[0];
    });
  }
  fetchAutoFlow(t) {
    return x(this, null, function* () {
      return this.userFlows[t] || (this.userFlows[t] = new Promise(
        (s, n) => x(this, null, function* () {
          try {
            const r = yield (yield fetch(
              `${this._baseUrl}/flow?id=${t}&auto=true`
            )).json();
            s(r.item);
          } catch (i) {
            n(i);
          }
        })
      )), yield this.userFlows[t];
    });
  }
  fetchFlow(t) {
    return x(this, null, function* () {
      return this.userFlows[t] || (this.userFlows[t] = new Promise(
        (s, n) => x(this, null, function* () {
          try {
            const r = yield (yield fetch(
              `${this._baseUrl}/flow?id=${t}&resolve=components`
            )).json();
            s(r.item);
          } catch (i) {
            n(i);
          }
        })
      )), yield this.userFlows[t];
    });
  }
  // ============ Backward Compatibility ============
  /**
   * @deprecated Use fetchComponentV2 or fetchComponentV1 explicitly
   * Defaults to v1 behavior for backward compatibility with existing code
   */
  fetchComponent(t, s) {
    return x(this, null, function* () {
      return this.fetchComponentV1(t, s);
    });
  }
};
p(ae, "Main", new ae());
var X = ae;
const Ws = (e) => {
  const t = H(null), s = H(null), n = H(!1), i = H(null);
  return ee(() => {
    let r = !1;
    n.current = !(t != null && t.current);
    const a = async (l) => {
      n.current = !0;
      try {
        const c = await X.Main.fetchComponent(
          l.componentId,
          l.flowId
        );
        s.current = await he.loadComponent(
          c,
          t.current,
          {
            _environment: {
              // // inputs: { ...attrs, ...props },
              props: { ...l }
              // slots: slotList,
              // context: instance?.appContext,
              // vueContainerRef: myopContainer,
              // //@ts-ignore
              // defineUpdater: (updater) => {
              //     innerUpdater.value = updater;
              // },
              // //@ts-ignore
              // defineInnerVueComponentRef: (vueComponentRef) => {
              //     //console.log('GOT new vueComponentRef');
              //     innerVueComponentRef.value = vueComponentRef.value
              // }
            }
          }
        ), r ? s.current && s.current.dispose() : l.onReady && l.onReady(s.current);
      } catch {
      } finally {
        if (n.current = !1, i.current !== null && !r) {
          const c = i.current;
          i.current = null, await a(c);
        }
      }
    };
    return n.current ? i.current = { ...e } : a(e).then(), () => {
      r = !0, s.current && s.current.dispose();
    };
  }, [e.flowId, e.componentId]), /* @__PURE__ */ E(
    "div",
    {
      style: {
        height: "100%",
        overflow: "inherit"
      },
      ref: t
    }
  );
}, Rs = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  background: "linear-gradient(135deg, #FF8651 0%, #FFBEA8 50%, #A397F5 100%)",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  transition: "opacity 0.2s ease-out"
}, ht = () => /* @__PURE__ */ E(
  "svg",
  {
    width: "80",
    viewBox: "0 0 525 243",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ E(
      "path",
      {
        d: "M151.438 2.7168C177.625 2.76042 248.179 4.2832 300.4 56.7441C350.671 107.245 364.44 114.452 389.967 119.211C392.576 119.436 397.472 119.394 400.802 116.521C403.011 114.614 403.921 109.518 404.265 104.627V5.95996C404.265 4.85556 405.16 3.96023 406.265 3.95996H522.711C523.815 3.95996 524.711 4.85539 524.711 5.95996V122.405C524.711 123.51 523.815 124.405 522.711 124.405H421.998C418.579 124.728 413.852 125.627 410.974 128.095C407.879 130.748 407.042 137.805 406.845 142.661V240.414C406.845 241.436 406.111 242.292 405.093 242.38C366.548 245.717 277.079 228.462 235.837 173.668C202.909 129.919 173.882 122.474 151.458 122.077C150.354 122.058 149.459 121.164 149.459 120.06V4.71582C149.459 3.6114 150.334 2.71519 151.438 2.7168ZM62.2031 0C96.5566 0.000213148 124.405 27.8496 124.405 62.2031C124.405 96.5564 96.5564 124.405 62.2031 124.405C27.8496 124.405 0.000213175 96.5566 0 62.2031C0 27.8495 27.8495 0 62.2031 0Z",
        fill: "white"
      }
    )
  }
), Hs = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
}, ks = ({
  opacity: e = 1,
  fadeDuration: t = 200,
  children: s
}) => s !== void 0 ? /* @__PURE__ */ E(
  "div",
  {
    style: {
      ...Hs,
      opacity: e,
      transition: `opacity ${t}ms ease-out`
    },
    children: s
  }
) : /* @__PURE__ */ E(
  "div",
  {
    style: {
      ...Rs,
      opacity: e,
      transitionDuration: `${t}ms`
    },
    children: /* @__PURE__ */ E(ht, {})
  }
), Ds = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  background: "linear-gradient(135deg, #9CA3AF 0%, #D1D5DB 50%, #E5E7EB 100%)",
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, $s = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
}, Ls = ({ children: e }) => e !== void 0 ? /* @__PURE__ */ E("div", { style: $s, children: e }) : /* @__PURE__ */ E("div", { style: Ds, children: /* @__PURE__ */ E(ht, {}) }), Os = (e) => `on${e.split("-").map((s) => s.charAt(0).toUpperCase() + s.slice(1)).join("")}`, js = (e) => {
  const t = H(null), s = H(null), n = H(!1), i = H(null), r = e.componentId ? Fs(e.componentId, e.environment, e.preview) : !1, [a, l] = j(!r), [c, d] = j(1), [u, h] = j(!1), [m, f] = j(!1), v = e.fadeDuration ?? 200, O = ye(() => {
    d(0), setTimeout(() => {
      l(!1);
    }, v);
  }, [v]), A = ye(
    (C) => {
      console.error("[MyopComponent] Error:", C), O(), h(!0), e.onError && e.onError(C);
    },
    [O, e.onError]
  );
  return ee(() => {
    if (m && e.data !== void 0 && s.current) {
      const C = s.current.props.myop_init_interface;
      C && C(e.data);
    }
  }, [e.data, m]), ee(() => {
    let C = !1;
    n.current = !(t != null && t.current);
    const pe = async (T) => {
      n.current = !0;
      try {
        if (!T.componentId && !T.componentConfig) {
          A("No component configuration provided");
          return;
        }
        const $ = T.environment || xe().getDefaultEnvironment(), pt = await xe().fetchComponentV2(
          T.componentId,
          $,
          T.preview
        );
        if (s.current = await he.loadComponent(
          pt,
          t.current,
          {
            _environment: {
              props: { ...T }
            }
          }
        ), C)
          s.current && s.current.dispose();
        else {
          if (f(!0), O(), s.current && (s.current.props.myop_cta_handler = (K, me) => {
            e.on && e.on(K, me);
            const mt = Os(K), fe = e[mt];
            typeof fe == "function" && fe(me);
          }), e.data !== void 0 && s.current) {
            const K = s.current.props.myop_init_interface;
            K && K(e.data);
          }
          T.onLoad && T.onLoad(s.current);
        }
      } catch ($) {
        C || A(($ == null ? void 0 : $.message) || "Unknown error");
      } finally {
        if (n.current = !1, i.current !== null && !C) {
          const $ = i.current;
          i.current = null, await pe($);
        }
      }
    };
    return n.current ? i.current = { ...e } : pe(e).then(), () => {
      C = !0, s.current && s.current.dispose();
    };
  }, [e.componentId]), /* @__PURE__ */ ft(
    "div",
    {
      style: {
        position: "relative",
        height: "100%",
        width: "100%",
        overflow: "inherit",
        ...e.style
      },
      children: [
        /* @__PURE__ */ E(
          "div",
          {
            ref: t,
            style: { position: "absolute", inset: 0 }
          }
        ),
        a && /* @__PURE__ */ E(ks, { opacity: c, fadeDuration: v, children: e.loader }),
        u && /* @__PURE__ */ E(Ls, { children: e.fallback })
      ]
    }
  );
};
let L = X.Main;
const xe = () => L, Fs = (e, t, s) => L.isPreloaded(e, t, s), Gs = () => {
  L = new X("http://localhost:9292");
}, Ys = (e) => {
  L = new X(e);
}, Js = (e) => {
  L = e;
}, Zs = (e) => {
  L.setEnvironment(e);
}, Xs = async (e, t, s) => Promise.allSettled(
  e.map((n) => L.fetchComponentV2(n, t, s))
);
export {
  js as MyopComponent,
  Ws as MyopContainer,
  js as MyopV2Container,
  Gs as enableLocalDev,
  xe as getCloudRepository,
  Fs as isPreloaded,
  Xs as preloadComponents,
  Js as setCloudRepository,
  Ys as setCloudRepositoryUrl,
  Zs as setEnvironment
};
